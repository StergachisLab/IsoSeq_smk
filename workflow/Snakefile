import os
import yaml

configfile: 'config.yaml'


labels = []
for individual in config['individuals']:
    for condition in ["treated", "untreated"]:
        for label in config['individuals'][individual][condition]:
            labels.append(label)


# Global wildcard constraints
wildcard_constraints:
    individual = "|".join(config["individuals"]),
    condition = "treated|untreated",
    label = "|".join(labels),



def has_vcf(wc):
    return "deepvariant_vcf" in config["individuals"][wc.individual]

def get_mod_phased_vcf(wc):
    phased_vcf = f"mod_vcf/{individual}_mod.vcf.gz"
    if not has_vcf(wc):
        return f"mod_vcf/fake_{individual}_mod.vcf.gz"
    return phased_vcf

def get_merge_input(wc):
    return config["individuals"][wc.individual][wc.condition][wc.label]

# Function to combine samples from conditions [treated/untreated]
def combine_labels(wildcards):
    individual = wildcards.individual
    rtn = []
    for condition in ["treated", "untreated"]:
        for label in config["individuals"][individual][condition]:
            file = f"merged/{individual}_{condition}_{label}_labeled.bam"
            rtn.append(file)
    return rtn


def whatshap_outs(wc):
    template_f_path = "whatshap/{individual}_{condition}_{label}.list.txt"
    rtn = []
    for individual in config['individuals']:
        for condition in ["treated", "untreated"]:
            for label in config['individuals'][individual][condition]:
                rtn.append(template_f_path.format(
                    individual=individual,
                    condition=condition,
                    label=label
                ))
    return rtn 

rule all:
    input:
        "pigeon/saturation.txt",
        whatshap_outs


rule merge_individual_condition:
    conda:
        "envs/env.yml"
    input:
        get_merge_input
    output:
        bam = "merged/{individual}_{condition}_{label}_merged.bam"
    threads: config.get("threads", 40)
    shell:
        "samtools merge -@ {threads} {output.bam} {input}"

rule label_reads_with_condition:
    conda:
        "envs/env.yml"
    input:
        bam = "merged/{individual}_{condition}_{label}_merged.bam"
    output:
        bam = "merged/{individual}_{condition}_{label}_labeled.bam",
        header = temp("{individual}_{condition}_{label}_header.sam")
    shell:
        r"""
        samtools view -H {input.bam} > {output.header}
        (samtools view {input.bam} | \
        awk -v label="{wildcards.label}" 'BEGIN {{OFS="\t"}} {{print label"_"$0}}') | \
        samtools view -bS -T {output.header} > {output.bam}
        samtools index -@ {threads} {output.bam}
        """

rule align_sample:
    conda:
        "envs/env.yml"
    input:
        bam = "merged/{individual}_{condition}_{label}_labeled.bam"
    output:
        aligned = "aligned/{individual}_{condition}_{label}_aligned.bam"
    threads: config.get("threads", 40)
    shell:
        """
        pbmm2 align {config[reference_genome]} {input.bam} {output.aligned} --preset ISOSEQ --sort -j {threads} --sort-memory 4G --log-level INFO
        """

rule modify_rg:
    conda:
        "envs/env.yml"
    input:
        bam = "aligned/{individual}_{condition}_{label}_aligned.bam"
    output:
        bam = "aligned/{individual}_{condition}_{label}_modified_aligned.bam",
        bai = "aligned/{individual}_{condition}_{label}_modified_aligned.bam.bai"
    shell:
        """
        samtools addreplacerg -r '@RG\\tID:rg1\\tSM:UnnamedSample\\tLB:lib1\\tPL:PACBIO' -o {output.bam} {input.bam}
        samtools index {output.bam}
        """


rule modify_vcf:
    conda:
        "envs/env.yml"
    input:
        vcf = lambda wildcards: config['individuals'][wildcards.individual]['deepvariant_vcf']
    output:
        mod_vcf = "mod_vcf/{individual}_mod.vcf.gz",
        mod_vcf_tbi = "mod_vcf/{individual}_mod.vcf.gz.tbi"
    shell:
        r"""
        if [[ "{input.vcf}" =~ \.gz$ ]]; then
            zcat {input.vcf}
        else
            cat {input.vcf}
        fi | \
        bcftools view | \
        awk 'BEGIN {{FS=OFS="\t"}} /^#CHROM/ {{$10="UnnamedSample"; print; next}} {{print}}' | \
        bgzip -c > {output.mod_vcf} && \
        tabix -p vcf {output.mod_vcf}
        """

rule fake_vcf:
    conda:
        "envs/env.yml"
    output:
        temp("mod_vcf/fake_{individual}_mod.vcf.gz"),
    shell:
        """
        touch {output}
        """
        

rule whatshap_stats:
    conda:
        "envs/env.yml"
    input:
        phased_vcf = "mod_vcf/{individual}_mod.vcf.gz"
    output:
        tsv = "whatshap/{individual}.phased_stats.tsv",
        block_list = "whatshap/{individual}.phased.blocks.txt",
        gtf = "whatshap/{individual}.phased.blocks.gtf"
    shell:
        """
        whatshap stats --tsv {output.tsv} --block-list {output.block_list} --gtf {output.gtf} {input.phased_vcf}
        """

rule whatshap_haplotag:
    conda:
        "envs/env.yml"
    input:
        phased_vcf_gz = get_mod_phased_vcf,
        bam = "aligned/{individual}_{condition}_{label}_modified_aligned.bam",
        reference = config['reference_genome']
    output:
        haplotagged_bam = "whatshap/{individual}_{condition}_{label}.haplotagged.bam",
        list_txt = "whatshap/{individual}_{condition}_{label}.list.txt"
    params:
        has_vcf = lambda wc: "true" if has_vcf(wc) else "false"
    shell:
        """
        if [ {params.has_vcf} == "true" ]; then
            whatshap haplotag {input.phased_vcf_gz} {input.bam} -o {output.haplotagged_bam} --reference {input.reference} --output-haplotag-list {output.list_txt}
        else
            # add back fake haplotpag script
            ./scripts/add_hp0.sh {input.bam} {output.haplotagged_bam}  
        fi
        """

rule extract_read_info:
    conda:
        "envs/env.yml"
    input:
        bam = "whatshap/{individual}_{condition}_{label}.haplotagged.bam"
    output:
        txt = "whatshap/{individual}_{condition}_{label}.txt"
    shell:
        """
        ./scripts/extract_read_info.py {input.bam}
        """

rule merge_samples:
    conda:
        "envs/env.yml"
    input:
        bam = combine_labels
    output:
        bam = "merged/{individual}_all_conditions_merged.bam",
        bai = "merged/{individual}_all_conditions_merged.bam.bai"
    threads: config.get("threads", 40)
    shell:
        """
        samtools merge -@ {threads} {output.bam} {input.bam}
        samtools index {output.bam}
        """

rule cluster:
    conda:
        "envs/env.yml"
    input:
        bam = "merged/{individual}_all_conditions_merged.bam",
        bai = "merged/{individual}_all_conditions_merged.bam.bai"
    output:
        clustered = "clustered/{individual}_clustered.bam"
    threads: config.get("threads", 40)
    resources: 
        runtime = 60*24
    shell:
        "isoseq3 cluster {input.bam} {output.clustered} --verbose -j {threads} --singletons"

rule align:
    conda:
        "envs/env.yml"
    input:
        "clustered/{individual}_clustered.bam"
    output:
        aligned="aligned/{individual}_aligned.bam"
    threads: config.get("threads", 40)
    shell:
        "pbmm2 align {config[reference_genome]} {input} {output.aligned} --preset ISOSEQ --sort -j {threads} --sort-memory 40G --log-level INFO"

rule label_transcripts:
    conda:
        "envs/env.yml"
    input:
        "aligned/{individual}_aligned.bam"
    output:
        bam = "aligned/{individual}_aligned_labeled.bam",
        header = temp("{individual}_aligned_header.sam")
    #params:
    #    individual_label=lambda wildcards: config['individuals'][wildcards.individual]['label']
    shell:
        """
        samtools view -H {input} > {output.header}
        samtools view {input} | awk -v label="{wildcards.individual}" '{{print label"_"$$0}}' | cat {output.header} - | samtools view -bS > {output.bam}
        """


rule merge_all_aligned:
    conda:
        "envs/env.yml"
    input:
        lambda wildcards: expand("aligned/{individual}_aligned_labeled.bam", individual=config['individuals'].keys())
    output:
        "aligned/all_individuals_aligned_merged.bam"
    shell:
        """
        samtools merge -@ 40 {output} {input}
        samtools index {output}
        """

rule collapse:
    conda:
        "envs/env.yml"
    input:
        "aligned/all_individuals_aligned_merged.bam"
    output:
        collapsed_gff="collapse/collapsed.gff"
    shell:
        "isoseq3 collapse {input} {output.collapsed_gff} --verbose"

rule pigeon_process:
    conda:
        "envs/env.yml"
    input:
        collapsed_gff="collapse/collapsed.gff"
    output:
        report="pigeon/saturation.txt"
    params:
        pigeon_annot=config['pigeon_annot']
    shell:
        """
        pigeon sort {input.collapsed_gff} -o pigeon/sorted.gff
        pigeon classify pigeon/sorted.gff {params.pigeon_annot} {config[reference_genome]} --flnc collapse/collapsed.flnc_count.txt -d pigeon -o 'pigeon'
        pigeon filter pigeon/pigeon_classification.txt
        pigeon report pigeon/pigeon_classification.filtered_lite_classification.txt {output.report}
        """
